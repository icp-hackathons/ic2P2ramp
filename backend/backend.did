type ChainConfig = record {
  chain_id : nat64;
  vault_manager_address : text;
  services : RpcServices;
};
type EcdsaCurve = variant { secp256k1 };
type EcdsaKeyId = record { name : text; curve : EcdsaCurve };
type EthMainnetService = variant {
  Alchemy;
  BlockPi;
  Cloudflare;
  PublicNode;
  Ankr;
};
type EthSepoliaService = variant { Alchemy; BlockPi; PublicNode; Ankr };
type ExchangeRateError = variant {
  AnonymousPrincipalNotAllowed;
  CryptoQuoteAssetNotFound;
  FailedToAcceptCycles;
  ForexBaseAssetNotFound;
  CryptoBaseAssetNotFound;
  StablecoinRateTooFewRates;
  ForexAssetsNotFound;
  InconsistentRatesReceived;
  RateLimited;
  StablecoinRateZeroRate;
  Other : record { code : nat32; description : text };
  ForexInvalidTimestamp;
  NotEnoughCycles;
  ForexQuoteAssetNotFound;
  StablecoinRateNotFound;
  Pending;
};
type HttpHeader = record { value : text; name : text };
type InitArg = record {
  ecdsa_key_id : EcdsaKeyId;
  chains : vec ChainConfig;
  client_id : text;
  client_secret : text;
};
type LockedOrder = record {
  locked_at : nat64;
  payment_done : bool;
  base : Order;
  proof_submitted : bool;
  onramper_address : text;
  onramper_provider : PaymentProvider;
};
type Order = record {
  id : text;
  originator : principal;
  token_address : opt text;
  fiat_amount : nat64;
  currency_symbol : text;
  created_at : nat64;
  chain_id : nat64;
  offramper_providers : vec PaymentProvider;
  offramper_address : text;
  crypto_amount : nat64;
};
type OrderState = variant {
  Locked : LockedOrder;
  Cancelled : text;
  Created : Order;
  Completed : text;
};
type PaymentProvider = variant {
  PayPal : record { id : text };
  Revolut : record { id : text };
};
type ProviderView = record {
  cyclesPerCall : nat64;
  owner : principal;
  hostname : text;
  primary : bool;
  chainId : nat64;
  cyclesPerMessageByte : nat64;
  providerId : nat64;
};
type RampError = variant {
  TokenAlreadyRegistered;
  InvalidAddress;
  HttpRequestError : record { nat64; text };
  TransactionTimeout;
  PaymentVerificationFailed;
  InvalidInput : text;
  InvalidOnramperProvider;
  UserBanned;
  ExchangeRateError : ExchangeRateError;
  TransactionFailed : text;
  ParseFloatError : text;
  OrderNotFound;
  ProviderNotInUser : text;
  EthersAbiError : text;
  ChainIdNotFound : nat64;
  TokenUnregistered;
  ParseError : text;
  NonceTooLow;
  EmptyTransactionHash;
  InvalidOrderState : text;
  NonceTooHigh;
  CanisterCallError : text;
  Utf8Error;
  VaultManagerAddressNotFound : nat64;
  UserNotFound;
  InsufficientFunds;
  OrderCreateFailed;
};
type Result = variant { Ok; Err : RampError };
type Result_1 = variant { Ok : text; Err : RampError };
type Result_2 = variant { Ok : User; Err : RampError };
type RpcApi = record { url : text; headers : opt vec HttpHeader };
type RpcServices = variant {
  EthSepolia : opt vec EthSepoliaService;
  Custom : record { chainId : nat64; services : vec RpcApi };
  EthMainnet : opt vec EthMainnetService;
};
type User = record {
  offramped_amount : nat64;
  evm_address : text;
  payment_providers : vec PaymentProvider;
  score : int32;
};
service : (InitArg) -> {
  add_payment_provider_for_user : (text, PaymentProvider) -> (Result) query;
  approve_token_allowance : (nat64, text, int32) -> (Result);
  cancel_order : (text) -> (Result_1);
  create_order : (
      nat64,
      text,
      nat64,
      vec PaymentProvider,
      text,
      nat64,
      opt text,
    ) -> (Result_1);
  get_evm_address : () -> (text) query;
  get_orders : () -> (vec OrderState) query;
  get_rpc_providers : () -> (vec ProviderView) query;
  get_usd_exchange_rate : (text, text) -> (Result_1);
  get_user : (text) -> (Result_2) query;
  lock_order : (text, PaymentProvider, text, opt int32) -> (Result);
  register_user : (text, vec PaymentProvider) -> (Result_1);
  test_deposit_funds : (nat64, nat64, opt text, opt int32) -> (Result_1);
  unlock_order : (text, opt nat64) -> (Result);
  verify_transaction : (text, text, opt int32) -> (Result);
}
